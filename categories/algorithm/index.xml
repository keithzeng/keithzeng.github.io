<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on k317h</title>
    <link>https://keithzeng.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on k317h</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 Feb 2019 18:50:42 -0800</lastBuildDate>
    
	<atom:link href="https://keithzeng.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sequence Alignment Revisited</title>
      <link>https://keithzeng.github.io/posts/sequence-alignment-revisited/</link>
      <pubDate>Sat, 09 Feb 2019 18:50:42 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/sequence-alignment-revisited/</guid>
      <description>Problem1 Sequence Alignment
We can reduce the space by using only two column instead.
Space-Efficient-Alignment(X ,Y)
 Array B[0&amp;hellip;m,0&amp;hellip;1] Initialize B[i,0]=iδ for each i (just as in column 0 of A) For j=1,&amp;hellip;,n  B[0,1]=j$\delta$ (since this corresponds to entry A[0,j]) For i=1,&amp;hellip;,m  B[i, 1]= min[$\alpha x_iy_j$ + B[i − 1, 0], $\delta$ + B[i−1,1], $\delta$ + B[i,0]]  Endfor Move column 1 of B to column 0 to make room for next iteration:  Update B[i, 0]= B[i, 1] for each i   Endfor  However, this doesn&amp;rsquo;t left enough information to get back the information about alignment.</description>
    </item>
    
    <item>
      <title>Sequence Alignment</title>
      <link>https://keithzeng.github.io/posts/sequence-alignment/</link>
      <pubDate>Sat, 09 Feb 2019 17:56:45 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/sequence-alignment/</guid>
      <description>Problem1 When you type &amp;ldquo;ocurrance&amp;rdquo;, the brower will will prompt “Perhaps you mean occurrence?”
How does the search engine knows?
How does it know the most similar word?
How do we determine the similarity between words?
The definition of similarity will be based on the optimal alignment between X and Y where X = $x_1x_2 &amp;hellip; x_m$, Y = $y_1y_2 &amp;hellip; y_n$.
 when there is gap (character not matched), we pay $\delta$ when we match character p and q, we pay $\alpha_{pq}$, where $\alpha_{pq}$ = 0 goal is to minimize the sum of cost.</description>
    </item>
    
    <item>
      <title>RNA Secondary Structure</title>
      <link>https://keithzeng.github.io/posts/rna-secondary-structure/</link>
      <pubDate>Sat, 09 Feb 2019 17:07:21 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/rna-secondary-structure/</guid>
      <description>Problem1 We have bases of {A,C,G,T} in DNA sequence, where A-T and C-G form a pair. A sinlge strand of RNA will loop back, resulting shape called secondary structure.
Let $B = b_1b_2 &amp;hellip; b_n$, where $b_i$ = {A,C,G,U} also A-U, C-G form pair
Then the Secondary structure, S ={(i, j)}
 no sharp turn, i &amp;lt; j - 4 pair is either {A,U}, {C,G} (either order) no base appear in more than 1 matching no crossing condition, (i,j) and (k, l) $\in$ S, we can&amp;rsquo;t have i &amp;lt; k &amp;lt; j &amp;lt; l  Algorithm Following the same analysis</description>
    </item>
    
    <item>
      <title>Knapsack</title>
      <link>https://keithzeng.github.io/posts/knapsack/</link>
      <pubDate>Sat, 09 Feb 2019 14:09:38 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/knapsack/</guid>
      <description>Problem1 Each request has value $v_i$ and weight $w_i$, and we have constraint that the total of request weight $\leq$ W.
Greedy doesn&amp;rsquo;t work because sorting the W either in decreasing or increasing manner don&amp;rsquo;t produce the optimal solution.
 {W/2 + 1, W/2, W/2} {1, W/2, W/2}  Using dynamic programing, we can use reduce this problem to whether or not each request belongs to the optimal solution O again.</description>
    </item>
    
    <item>
      <title>Segmented Least Square</title>
      <link>https://keithzeng.github.io/posts/segmented-least-square/</link>
      <pubDate>Sat, 09 Feb 2019 12:54:29 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/segmented-least-square/</guid>
      <description>Problem1 Data $P = (x_1,y_1), (x_2, y_2)&amp;hellip;(x_n, y_n)$ for $x_1 &amp;lt; x_2 &amp;lt; &amp;hellip; &amp;lt; x_n$.
Given a line y=ax+b, and error
$$Error(L, P) = \sum_{i=1}^n(y_i - ax_i -b)^2$$
And it has closed form solution of
$$a = \frac{n\sum_i x_iy_i - (\sum_i x_i)(\sum_i y_i)}{n\sum_i x_i^2 - (\sum_i x_i)^2}$$
and
$$b = \frac {\sum_i y_i - a \sum_i x_i}{n}$$
However, if the data is show as below (maybe fitted with two lines), we can&amp;rsquo;t just use the above formula.</description>
    </item>
    
    <item>
      <title>Weighted Interval Scheduling</title>
      <link>https://keithzeng.github.io/posts/weighted-interval-scheduling/</link>
      <pubDate>Fri, 08 Feb 2019 23:22:27 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/weighted-interval-scheduling/</guid>
      <description>Problem1 Instead of just fitting as many tasks like regular interval scheduling problem, we have weight associates with the interval. Now we want to maximize the value.
So basically, $f_i$ finish time sorted in non-decreasing order, $v_i$ is the value, and $s_i$ is the start time. We want $S \subseteq {1&amp;hellip; n}$.
We also define $p(j)$ which is the largest i &amp;lt; j which is disjoint(compatible) with j.
Algorithm Idea:</description>
    </item>
    
    <item>
      <title>Fast Fourtier Transform</title>
      <link>https://keithzeng.github.io/posts/fast-fourtier-transform/</link>
      <pubDate>Wed, 30 Jan 2019 00:31:46 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/fast-fourtier-transform/</guid>
      <description>Problem Given two vectors $a = (a_1, a_2, a_{n-1})$ and $b = (a_1, b_2, b_{n-1})$.
The convolution of a * b is a vector with 2n - 1 coordinates, where coordinate k is $\sum_{(i,j):i+j=k|i,j &amp;lt; n} a_ib_j$, which is can be written as
$$a ∗ b = (a_0b_0, a_0b_1 + a_1b_0, a_0b_2 + a_1b_1 + a_2b_0, &amp;hellip; , a_{n−2}b_{n−1} + a_{n−1}b_{n−2}, a_{n−1}b_{n−1})$$
Or an n x n table, whose (i, j) entry is $a_ib_j$</description>
    </item>
    
    <item>
      <title>Integer Multiplication</title>
      <link>https://keithzeng.github.io/posts/integer-multiplication/</link>
      <pubDate>Wed, 30 Jan 2019 00:02:09 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/integer-multiplication/</guid>
      <description>Problem Wiki Explanation
Algorithm Let&amp;rsquo;s say we define $x = x_1 2^{n/2} + x_0$, then xy become \begin{align} xy &amp;amp;= (x_1 2^{n/2} + x_0)(y_1 2^{n/2} + y_0) \newline &amp;amp;= x_1 y_1 2^n + (x_1 y_0 + x_0 y_1)2^{n/2} + x_0 y_0 \end{align}
So we have $$T(n) \leq 4T(n/2) + cn$$ But this is essentially $$T(n) \leq O(n^{\log_2 q}) = O(n^2)$$
However, we can reduce the time by observing that $(x_1 + x_0)(y_1 + y_0) = x_1y_1 + x_1y_0 + x_0y_1 + x_0y_0$.</description>
    </item>
    
    <item>
      <title>Closest Point</title>
      <link>https://keithzeng.github.io/posts/closest-point/</link>
      <pubDate>Tue, 29 Jan 2019 23:36:54 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/closest-point/</guid>
      <description>Problem Given n points in the plane, find the pair that is closest together.
Brute force takes $O(n^2)$.
Algorithm Let&amp;rsquo;s $d(p_i, p_j)$ = Euclidean distance.
In 1-d, we can simply sort points and compute the distance with the next point, we then have complexity of O(nlogn). In 2-d, we can&amp;rsquo;t applied the same thing.
We will use divide and conquer. We find the closest pair in the left and closest pair in the right, and hoping to get it in linear time.</description>
    </item>
    
    <item>
      <title>Counting Inversion</title>
      <link>https://keithzeng.github.io/posts/counting-inversion/</link>
      <pubDate>Tue, 29 Jan 2019 22:37:45 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/counting-inversion/</guid>
      <description>Problem Application in ranking, also called corraborative filtering.
Comparing two rankings and decide how similar they are, or how many pairs are out of order.
To quantify this, we count the number of inversions. The inversion is defined as two indices i &amp;lt; j that $a_i &amp;gt; a_j$. Algorithm Brute-Force $T(n) = O(n^2)$
Modified Merge-Sort By leverage the merge process form merger-sort, we can count the number of inversion. Basically, when the element from A is appended, there is not inversion.</description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://keithzeng.github.io/posts/merge-sort/</link>
      <pubDate>Tue, 29 Jan 2019 01:14:32 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/merge-sort/</guid>
      <description>Problem Sort the elements
Abstract the behavior:
1. Divide the input into two pieces of equal size O(n) 1. solve the two subproblems on these pieces separately by recursion 1. combine the two results into an overall solution O(n)
Recurrence Time Complexity q = 2 T(n) ≤ 2T(n/2) + cn
To analyze the above recurrence relation, check below image.  At level j, we have $2^j$ nodes with size $n/2^j$ Each node takes $cn/2^j$, so level j takes $cn/2^j$ x $2^j = cn$ There are logn levels, so T(n) = O(nlogn)  General Case For q &amp;gt; 2 T(n) ≤ qT(n/2) + cn</description>
    </item>
    
    <item>
      <title>K Clustering</title>
      <link>https://keithzeng.github.io/posts/k-clustering/</link>
      <pubDate>Fri, 25 Jan 2019 21:51:25 -0800</pubDate>
      
      <guid>https://keithzeng.github.io/posts/k-clustering/</guid>
      <description>Problem We have set of objects $U = \{o_1, o_2, &amp;hellip;\}$, and we want to split them into k clusters.
We also have following definition for distance function.
 $\forall_{i,j} dist(p_i, p_j) = dist(p_j, p_j)$ $\forall_{i,j} dist(p_i, p_i) = 0$ $\forall_{i,j} dist(p_i, p_j) &amp;gt; 0$.  At the end, we should have $C = \{C_1, C_2, &amp;hellip; C_K\}$.
Let&amp;rsquo;s define spacing to be the minimum dist between clusters. Our goal is to find the k-clustering with maximum spacing.</description>
    </item>
    
  </channel>
</rss>